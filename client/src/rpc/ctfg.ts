// @generated by protobuf-ts 2.9.0
// @generated from protobuf file "proto/ctfg.proto" (package "ctfg", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message ctfg.Empty
 */
export interface Empty {
}
/**
 * @generated from protobuf message ctfg.UpsertChallengeRequest
 */
export interface UpsertChallengeRequest {
    /**
     * @generated from protobuf field: string challengeName = 1;
     */
    challengeName: string;
    /**
     * @generated from protobuf field: string flag = 2;
     */
    flag: string;
}
/**
 * @generated from protobuf message ctfg.DeleteChallengeRequest
 */
export interface DeleteChallengeRequest {
    /**
     * @generated from protobuf field: string challengeName = 1;
     */
    challengeName: string;
}
/**
 * @generated from protobuf message ctfg.SubmitEvidenceReportRequest
 */
export interface SubmitEvidenceReportRequest {
    /**
     * @generated from protobuf field: string url = 1;
     */
    url: string;
}
/**
 * @generated from protobuf message ctfg.SubmitEvidenceReportResponse
 */
export interface SubmitEvidenceReportResponse {
}
/**
 * @generated from protobuf message ctfg.LoginRequest
 */
export interface LoginRequest {
    /**
     * @generated from protobuf field: string email = 1;
     */
    email: string;
    /**
     * @generated from protobuf field: string password = 2;
     */
    password: string;
}
/**
 * @generated from protobuf message ctfg.LoginResponse
 */
export interface LoginResponse {
    /**
     * @generated from protobuf field: string username = 1;
     */
    username: string;
    /**
     * @generated from protobuf field: string userRole = 2;
     */
    userRole: string;
}
/**
 * @generated from protobuf message ctfg.Evidence
 */
export interface Evidence {
    /**
     * @generated from protobuf field: uint32 id = 1;
     */
    id: number;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: uint32 challengeID = 3;
     */
    challengeID: number;
    /**
     * @generated from protobuf field: int32 x = 4;
     */
    x: number;
    /**
     * @generated from protobuf field: int32 y = 5;
     */
    y: number;
    /**
     * @generated from protobuf field: bool isFlag = 6;
     */
    isFlag: boolean;
}
/**
 * @generated from protobuf message ctfg.Connection
 */
export interface Connection {
    /**
     * @generated from protobuf field: uint32 id = 1;
     */
    id: number;
    /**
     * @generated from protobuf field: uint32 source = 2;
     */
    source: number;
    /**
     * @generated from protobuf field: uint32 destination = 3;
     */
    destination: number;
}
/**
 * @generated from protobuf message ctfg.GetDiscoveredEvidenceRequest
 */
export interface GetDiscoveredEvidenceRequest {
}
/**
 * @generated from protobuf message ctfg.GetDiscoveredEvidenceResponse
 */
export interface GetDiscoveredEvidenceResponse {
    /**
     * @generated from protobuf field: string report = 1;
     */
    report: string;
    /**
     * @generated from protobuf field: repeated ctfg.Evidence evidence = 2;
     */
    evidence: Evidence[];
    /**
     * @generated from protobuf field: repeated ctfg.Connection connections = 3;
     */
    connections: Connection[];
}
/**
 * @generated from protobuf message ctfg.SubmitEvidenceRequest
 */
export interface SubmitEvidenceRequest {
    /**
     * this could either be the name of some evidence or a flag.
     *
     * @generated from protobuf field: string evidence = 1;
     */
    evidence: string;
    /**
     * @generated from protobuf field: int32 x = 2;
     */
    x: number;
    /**
     * @generated from protobuf field: int32 y = 3;
     */
    y: number;
    /**
     * @generated from protobuf field: bool isFlag = 4;
     */
    isFlag: boolean;
    /**
     * @generated from protobuf field: bool remove = 5;
     */
    remove: boolean;
}
/**
 * @generated from protobuf message ctfg.SubmitEvidenceResponse
 */
export interface SubmitEvidenceResponse {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
}
/**
 * @generated from protobuf message ctfg.SubmitEvidenceConnectionRequest
 */
export interface SubmitEvidenceConnectionRequest {
    /**
     * @generated from protobuf field: uint32 source = 1;
     */
    source: number;
    /**
     * @generated from protobuf field: uint32 destination = 2;
     */
    destination: number;
    /**
     * @generated from protobuf field: bool remove = 3;
     */
    remove: boolean;
}
/**
 * @generated from protobuf message ctfg.SubmitEvidenceConnectionResponse
 */
export interface SubmitEvidenceConnectionResponse {
    /**
     * @generated from protobuf field: bool created = 1;
     */
    created: boolean;
}
/**
 * @generated from protobuf message ctfg.RegisterRequest
 */
export interface RegisterRequest {
    /**
     * @generated from protobuf field: string username = 1;
     */
    username: string;
    /**
     * @generated from protobuf field: string email = 2;
     */
    email: string;
    /**
     * @generated from protobuf field: string password = 3;
     */
    password: string;
}
/**
 * @generated from protobuf message ctfg.RegisterResponse
 */
export interface RegisterResponse {
    /**
     * @generated from protobuf field: bool created = 1;
     */
    created: boolean;
}
/**
 * @generated from protobuf message ctfg.Page
 */
export interface Page {
    /**
     * @generated from protobuf field: string route = 1;
     */
    route: string;
    /**
     * @generated from protobuf field: string title = 2;
     */
    title: string;
    /**
     * @generated from protobuf field: string content = 3;
     */
    content: string;
}
/**
 * @generated from protobuf message ctfg.CurrentUserRequest
 */
export interface CurrentUserRequest {
}
/**
 * @generated from protobuf message ctfg.CurrentUserResponse
 */
export interface CurrentUserResponse {
    /**
     * @generated from protobuf field: string username = 1;
     */
    username: string;
    /**
     * @generated from protobuf field: string userRole = 2;
     */
    userRole: string;
    /**
     * @generated from protobuf field: repeated ctfg.Page pages = 3;
     */
    pages: Page[];
}
/**
 * @generated from protobuf message ctfg.SubmitFlagRequest
 */
export interface SubmitFlagRequest {
    /**
     * @generated from protobuf field: string flag = 1;
     */
    flag: string;
}
/**
 * @generated from protobuf message ctfg.SubmitFlagResponse
 */
export interface SubmitFlagResponse {
    /**
     * @generated from protobuf field: bool correct = 1;
     */
    correct: boolean;
}
/**
 * @generated from protobuf message ctfg.TeamProgress
 */
export interface TeamProgress {
    /**
     * @generated from protobuf field: string teamName = 1;
     */
    teamName: string;
    /**
     * @generated from protobuf field: uint32 score = 2;
     */
    score: number;
}
/**
 * @generated from protobuf message ctfg.GetTeamsProgressRequest
 */
export interface GetTeamsProgressRequest {
}
/**
 * @generated from protobuf message ctfg.GetTeamsProgressResponse
 */
export interface GetTeamsProgressResponse {
    /**
     * @generated from protobuf field: repeated ctfg.TeamProgress teams = 1;
     */
    teams: TeamProgress[];
}
/**
 * @generated from protobuf message ctfg.Challenge
 */
export interface Challenge {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string flag = 2;
     */
    flag: string;
}
/**
 * @generated from protobuf message ctfg.GetAllChallengesRequest
 */
export interface GetAllChallengesRequest {
}
/**
 * @generated from protobuf message ctfg.GetAllChallengesResponse
 */
export interface GetAllChallengesResponse {
    /**
     * @generated from protobuf field: repeated ctfg.Challenge challenges = 1;
     */
    challenges: Challenge[];
}
/**
 * @generated from protobuf message ctfg.SetHomePageRequest
 */
export interface SetHomePageRequest {
    /**
     * @generated from protobuf field: string content = 1;
     */
    content: string;
}
/**
 * @generated from protobuf message ctfg.GetHomePageRequest
 */
export interface GetHomePageRequest {
}
/**
 * @generated from protobuf message ctfg.GetHomePageResponse
 */
export interface GetHomePageResponse {
    /**
     * @generated from protobuf field: string content = 1;
     */
    content: string;
}
/**
 * @generated from protobuf message ctfg.ForgotPasswordRequest
 */
export interface ForgotPasswordRequest {
    /**
     * @generated from protobuf field: string email = 1;
     */
    email: string;
}
/**
 * @generated from protobuf message ctfg.SubmitWriteupRequest
 */
export interface SubmitWriteupRequest {
    /**
     * @generated from protobuf field: string content = 1;
     */
    content: string;
}
/**
 * @generated from protobuf message ctfg.GetWriteupRequest
 */
export interface GetWriteupRequest {
    /**
     * @generated from protobuf field: string username = 1;
     */
    username: string;
}
/**
 * @generated from protobuf message ctfg.GetWriteupResponse
 */
export interface GetWriteupResponse {
    /**
     * @generated from protobuf field: string content = 1;
     */
    content: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class Empty$Type extends MessageType<Empty> {
    constructor() {
        super("ctfg.Empty", []);
    }
    create(value?: PartialMessage<Empty>): Empty {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Empty>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Empty): Empty {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Empty, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ctfg.Empty
 */
export const Empty = new Empty$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpsertChallengeRequest$Type extends MessageType<UpsertChallengeRequest> {
    constructor() {
        super("ctfg.UpsertChallengeRequest", [
            { no: 1, name: "challengeName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "flag", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UpsertChallengeRequest>): UpsertChallengeRequest {
        const message = { challengeName: "", flag: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UpsertChallengeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpsertChallengeRequest): UpsertChallengeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string challengeName */ 1:
                    message.challengeName = reader.string();
                    break;
                case /* string flag */ 2:
                    message.flag = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpsertChallengeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string challengeName = 1; */
        if (message.challengeName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.challengeName);
        /* string flag = 2; */
        if (message.flag !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.flag);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ctfg.UpsertChallengeRequest
 */
export const UpsertChallengeRequest = new UpsertChallengeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteChallengeRequest$Type extends MessageType<DeleteChallengeRequest> {
    constructor() {
        super("ctfg.DeleteChallengeRequest", [
            { no: 1, name: "challengeName", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteChallengeRequest>): DeleteChallengeRequest {
        const message = { challengeName: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeleteChallengeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteChallengeRequest): DeleteChallengeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string challengeName */ 1:
                    message.challengeName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteChallengeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string challengeName = 1; */
        if (message.challengeName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.challengeName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ctfg.DeleteChallengeRequest
 */
export const DeleteChallengeRequest = new DeleteChallengeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubmitEvidenceReportRequest$Type extends MessageType<SubmitEvidenceReportRequest> {
    constructor() {
        super("ctfg.SubmitEvidenceReportRequest", [
            { no: 1, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SubmitEvidenceReportRequest>): SubmitEvidenceReportRequest {
        const message = { url: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubmitEvidenceReportRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubmitEvidenceReportRequest): SubmitEvidenceReportRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string url */ 1:
                    message.url = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubmitEvidenceReportRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string url = 1; */
        if (message.url !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.url);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ctfg.SubmitEvidenceReportRequest
 */
export const SubmitEvidenceReportRequest = new SubmitEvidenceReportRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubmitEvidenceReportResponse$Type extends MessageType<SubmitEvidenceReportResponse> {
    constructor() {
        super("ctfg.SubmitEvidenceReportResponse", []);
    }
    create(value?: PartialMessage<SubmitEvidenceReportResponse>): SubmitEvidenceReportResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubmitEvidenceReportResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubmitEvidenceReportResponse): SubmitEvidenceReportResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubmitEvidenceReportResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ctfg.SubmitEvidenceReportResponse
 */
export const SubmitEvidenceReportResponse = new SubmitEvidenceReportResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoginRequest$Type extends MessageType<LoginRequest> {
    constructor() {
        super("ctfg.LoginRequest", [
            { no: 1, name: "email", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "password", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LoginRequest>): LoginRequest {
        const message = { email: "", password: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LoginRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoginRequest): LoginRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string email */ 1:
                    message.email = reader.string();
                    break;
                case /* string password */ 2:
                    message.password = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoginRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string email = 1; */
        if (message.email !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.email);
        /* string password = 2; */
        if (message.password !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.password);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ctfg.LoginRequest
 */
export const LoginRequest = new LoginRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoginResponse$Type extends MessageType<LoginResponse> {
    constructor() {
        super("ctfg.LoginResponse", [
            { no: 1, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "userRole", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LoginResponse>): LoginResponse {
        const message = { username: "", userRole: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LoginResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoginResponse): LoginResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string username */ 1:
                    message.username = reader.string();
                    break;
                case /* string userRole */ 2:
                    message.userRole = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoginResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string username = 1; */
        if (message.username !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.username);
        /* string userRole = 2; */
        if (message.userRole !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.userRole);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ctfg.LoginResponse
 */
export const LoginResponse = new LoginResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Evidence$Type extends MessageType<Evidence> {
    constructor() {
        super("ctfg.Evidence", [
            { no: 1, name: "id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "challengeID", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "x", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "y", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "isFlag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Evidence>): Evidence {
        const message = { id: 0, name: "", challengeID: 0, x: 0, y: 0, isFlag: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Evidence>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Evidence): Evidence {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 id */ 1:
                    message.id = reader.uint32();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* uint32 challengeID */ 3:
                    message.challengeID = reader.uint32();
                    break;
                case /* int32 x */ 4:
                    message.x = reader.int32();
                    break;
                case /* int32 y */ 5:
                    message.y = reader.int32();
                    break;
                case /* bool isFlag */ 6:
                    message.isFlag = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Evidence, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).uint32(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* uint32 challengeID = 3; */
        if (message.challengeID !== 0)
            writer.tag(3, WireType.Varint).uint32(message.challengeID);
        /* int32 x = 4; */
        if (message.x !== 0)
            writer.tag(4, WireType.Varint).int32(message.x);
        /* int32 y = 5; */
        if (message.y !== 0)
            writer.tag(5, WireType.Varint).int32(message.y);
        /* bool isFlag = 6; */
        if (message.isFlag !== false)
            writer.tag(6, WireType.Varint).bool(message.isFlag);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ctfg.Evidence
 */
export const Evidence = new Evidence$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Connection$Type extends MessageType<Connection> {
    constructor() {
        super("ctfg.Connection", [
            { no: 1, name: "id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "source", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "destination", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Connection>): Connection {
        const message = { id: 0, source: 0, destination: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Connection>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Connection): Connection {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 id */ 1:
                    message.id = reader.uint32();
                    break;
                case /* uint32 source */ 2:
                    message.source = reader.uint32();
                    break;
                case /* uint32 destination */ 3:
                    message.destination = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Connection, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).uint32(message.id);
        /* uint32 source = 2; */
        if (message.source !== 0)
            writer.tag(2, WireType.Varint).uint32(message.source);
        /* uint32 destination = 3; */
        if (message.destination !== 0)
            writer.tag(3, WireType.Varint).uint32(message.destination);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ctfg.Connection
 */
export const Connection = new Connection$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDiscoveredEvidenceRequest$Type extends MessageType<GetDiscoveredEvidenceRequest> {
    constructor() {
        super("ctfg.GetDiscoveredEvidenceRequest", []);
    }
    create(value?: PartialMessage<GetDiscoveredEvidenceRequest>): GetDiscoveredEvidenceRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetDiscoveredEvidenceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDiscoveredEvidenceRequest): GetDiscoveredEvidenceRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetDiscoveredEvidenceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ctfg.GetDiscoveredEvidenceRequest
 */
export const GetDiscoveredEvidenceRequest = new GetDiscoveredEvidenceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDiscoveredEvidenceResponse$Type extends MessageType<GetDiscoveredEvidenceResponse> {
    constructor() {
        super("ctfg.GetDiscoveredEvidenceResponse", [
            { no: 1, name: "report", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "evidence", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Evidence },
            { no: 3, name: "connections", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Connection }
        ]);
    }
    create(value?: PartialMessage<GetDiscoveredEvidenceResponse>): GetDiscoveredEvidenceResponse {
        const message = { report: "", evidence: [], connections: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetDiscoveredEvidenceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDiscoveredEvidenceResponse): GetDiscoveredEvidenceResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string report */ 1:
                    message.report = reader.string();
                    break;
                case /* repeated ctfg.Evidence evidence */ 2:
                    message.evidence.push(Evidence.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated ctfg.Connection connections */ 3:
                    message.connections.push(Connection.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDiscoveredEvidenceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string report = 1; */
        if (message.report !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.report);
        /* repeated ctfg.Evidence evidence = 2; */
        for (let i = 0; i < message.evidence.length; i++)
            Evidence.internalBinaryWrite(message.evidence[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated ctfg.Connection connections = 3; */
        for (let i = 0; i < message.connections.length; i++)
            Connection.internalBinaryWrite(message.connections[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ctfg.GetDiscoveredEvidenceResponse
 */
export const GetDiscoveredEvidenceResponse = new GetDiscoveredEvidenceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubmitEvidenceRequest$Type extends MessageType<SubmitEvidenceRequest> {
    constructor() {
        super("ctfg.SubmitEvidenceRequest", [
            { no: 1, name: "evidence", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "x", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "y", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "isFlag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "remove", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SubmitEvidenceRequest>): SubmitEvidenceRequest {
        const message = { evidence: "", x: 0, y: 0, isFlag: false, remove: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubmitEvidenceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubmitEvidenceRequest): SubmitEvidenceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string evidence */ 1:
                    message.evidence = reader.string();
                    break;
                case /* int32 x */ 2:
                    message.x = reader.int32();
                    break;
                case /* int32 y */ 3:
                    message.y = reader.int32();
                    break;
                case /* bool isFlag */ 4:
                    message.isFlag = reader.bool();
                    break;
                case /* bool remove */ 5:
                    message.remove = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubmitEvidenceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string evidence = 1; */
        if (message.evidence !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.evidence);
        /* int32 x = 2; */
        if (message.x !== 0)
            writer.tag(2, WireType.Varint).int32(message.x);
        /* int32 y = 3; */
        if (message.y !== 0)
            writer.tag(3, WireType.Varint).int32(message.y);
        /* bool isFlag = 4; */
        if (message.isFlag !== false)
            writer.tag(4, WireType.Varint).bool(message.isFlag);
        /* bool remove = 5; */
        if (message.remove !== false)
            writer.tag(5, WireType.Varint).bool(message.remove);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ctfg.SubmitEvidenceRequest
 */
export const SubmitEvidenceRequest = new SubmitEvidenceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubmitEvidenceResponse$Type extends MessageType<SubmitEvidenceResponse> {
    constructor() {
        super("ctfg.SubmitEvidenceResponse", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SubmitEvidenceResponse>): SubmitEvidenceResponse {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubmitEvidenceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubmitEvidenceResponse): SubmitEvidenceResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubmitEvidenceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ctfg.SubmitEvidenceResponse
 */
export const SubmitEvidenceResponse = new SubmitEvidenceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubmitEvidenceConnectionRequest$Type extends MessageType<SubmitEvidenceConnectionRequest> {
    constructor() {
        super("ctfg.SubmitEvidenceConnectionRequest", [
            { no: 1, name: "source", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "destination", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "remove", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SubmitEvidenceConnectionRequest>): SubmitEvidenceConnectionRequest {
        const message = { source: 0, destination: 0, remove: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubmitEvidenceConnectionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubmitEvidenceConnectionRequest): SubmitEvidenceConnectionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 source */ 1:
                    message.source = reader.uint32();
                    break;
                case /* uint32 destination */ 2:
                    message.destination = reader.uint32();
                    break;
                case /* bool remove */ 3:
                    message.remove = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubmitEvidenceConnectionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 source = 1; */
        if (message.source !== 0)
            writer.tag(1, WireType.Varint).uint32(message.source);
        /* uint32 destination = 2; */
        if (message.destination !== 0)
            writer.tag(2, WireType.Varint).uint32(message.destination);
        /* bool remove = 3; */
        if (message.remove !== false)
            writer.tag(3, WireType.Varint).bool(message.remove);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ctfg.SubmitEvidenceConnectionRequest
 */
export const SubmitEvidenceConnectionRequest = new SubmitEvidenceConnectionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubmitEvidenceConnectionResponse$Type extends MessageType<SubmitEvidenceConnectionResponse> {
    constructor() {
        super("ctfg.SubmitEvidenceConnectionResponse", [
            { no: 1, name: "created", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SubmitEvidenceConnectionResponse>): SubmitEvidenceConnectionResponse {
        const message = { created: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubmitEvidenceConnectionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubmitEvidenceConnectionResponse): SubmitEvidenceConnectionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool created */ 1:
                    message.created = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubmitEvidenceConnectionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool created = 1; */
        if (message.created !== false)
            writer.tag(1, WireType.Varint).bool(message.created);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ctfg.SubmitEvidenceConnectionResponse
 */
export const SubmitEvidenceConnectionResponse = new SubmitEvidenceConnectionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterRequest$Type extends MessageType<RegisterRequest> {
    constructor() {
        super("ctfg.RegisterRequest", [
            { no: 1, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "email", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "password", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RegisterRequest>): RegisterRequest {
        const message = { username: "", email: "", password: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RegisterRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegisterRequest): RegisterRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string username */ 1:
                    message.username = reader.string();
                    break;
                case /* string email */ 2:
                    message.email = reader.string();
                    break;
                case /* string password */ 3:
                    message.password = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RegisterRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string username = 1; */
        if (message.username !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.username);
        /* string email = 2; */
        if (message.email !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.email);
        /* string password = 3; */
        if (message.password !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.password);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ctfg.RegisterRequest
 */
export const RegisterRequest = new RegisterRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterResponse$Type extends MessageType<RegisterResponse> {
    constructor() {
        super("ctfg.RegisterResponse", [
            { no: 1, name: "created", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<RegisterResponse>): RegisterResponse {
        const message = { created: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RegisterResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegisterResponse): RegisterResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool created */ 1:
                    message.created = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RegisterResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool created = 1; */
        if (message.created !== false)
            writer.tag(1, WireType.Varint).bool(message.created);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ctfg.RegisterResponse
 */
export const RegisterResponse = new RegisterResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Page$Type extends MessageType<Page> {
    constructor() {
        super("ctfg.Page", [
            { no: 1, name: "route", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "content", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Page>): Page {
        const message = { route: "", title: "", content: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Page>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Page): Page {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string route */ 1:
                    message.route = reader.string();
                    break;
                case /* string title */ 2:
                    message.title = reader.string();
                    break;
                case /* string content */ 3:
                    message.content = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Page, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string route = 1; */
        if (message.route !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.route);
        /* string title = 2; */
        if (message.title !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.title);
        /* string content = 3; */
        if (message.content !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.content);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ctfg.Page
 */
export const Page = new Page$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CurrentUserRequest$Type extends MessageType<CurrentUserRequest> {
    constructor() {
        super("ctfg.CurrentUserRequest", []);
    }
    create(value?: PartialMessage<CurrentUserRequest>): CurrentUserRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CurrentUserRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CurrentUserRequest): CurrentUserRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: CurrentUserRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ctfg.CurrentUserRequest
 */
export const CurrentUserRequest = new CurrentUserRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CurrentUserResponse$Type extends MessageType<CurrentUserResponse> {
    constructor() {
        super("ctfg.CurrentUserResponse", [
            { no: 1, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "userRole", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "pages", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Page }
        ]);
    }
    create(value?: PartialMessage<CurrentUserResponse>): CurrentUserResponse {
        const message = { username: "", userRole: "", pages: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CurrentUserResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CurrentUserResponse): CurrentUserResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string username */ 1:
                    message.username = reader.string();
                    break;
                case /* string userRole */ 2:
                    message.userRole = reader.string();
                    break;
                case /* repeated ctfg.Page pages */ 3:
                    message.pages.push(Page.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CurrentUserResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string username = 1; */
        if (message.username !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.username);
        /* string userRole = 2; */
        if (message.userRole !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.userRole);
        /* repeated ctfg.Page pages = 3; */
        for (let i = 0; i < message.pages.length; i++)
            Page.internalBinaryWrite(message.pages[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ctfg.CurrentUserResponse
 */
export const CurrentUserResponse = new CurrentUserResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubmitFlagRequest$Type extends MessageType<SubmitFlagRequest> {
    constructor() {
        super("ctfg.SubmitFlagRequest", [
            { no: 1, name: "flag", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SubmitFlagRequest>): SubmitFlagRequest {
        const message = { flag: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubmitFlagRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubmitFlagRequest): SubmitFlagRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string flag */ 1:
                    message.flag = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubmitFlagRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string flag = 1; */
        if (message.flag !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.flag);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ctfg.SubmitFlagRequest
 */
export const SubmitFlagRequest = new SubmitFlagRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubmitFlagResponse$Type extends MessageType<SubmitFlagResponse> {
    constructor() {
        super("ctfg.SubmitFlagResponse", [
            { no: 1, name: "correct", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SubmitFlagResponse>): SubmitFlagResponse {
        const message = { correct: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubmitFlagResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubmitFlagResponse): SubmitFlagResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool correct */ 1:
                    message.correct = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubmitFlagResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool correct = 1; */
        if (message.correct !== false)
            writer.tag(1, WireType.Varint).bool(message.correct);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ctfg.SubmitFlagResponse
 */
export const SubmitFlagResponse = new SubmitFlagResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TeamProgress$Type extends MessageType<TeamProgress> {
    constructor() {
        super("ctfg.TeamProgress", [
            { no: 1, name: "teamName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "score", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<TeamProgress>): TeamProgress {
        const message = { teamName: "", score: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TeamProgress>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TeamProgress): TeamProgress {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string teamName */ 1:
                    message.teamName = reader.string();
                    break;
                case /* uint32 score */ 2:
                    message.score = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TeamProgress, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string teamName = 1; */
        if (message.teamName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.teamName);
        /* uint32 score = 2; */
        if (message.score !== 0)
            writer.tag(2, WireType.Varint).uint32(message.score);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ctfg.TeamProgress
 */
export const TeamProgress = new TeamProgress$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTeamsProgressRequest$Type extends MessageType<GetTeamsProgressRequest> {
    constructor() {
        super("ctfg.GetTeamsProgressRequest", []);
    }
    create(value?: PartialMessage<GetTeamsProgressRequest>): GetTeamsProgressRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetTeamsProgressRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTeamsProgressRequest): GetTeamsProgressRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetTeamsProgressRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ctfg.GetTeamsProgressRequest
 */
export const GetTeamsProgressRequest = new GetTeamsProgressRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTeamsProgressResponse$Type extends MessageType<GetTeamsProgressResponse> {
    constructor() {
        super("ctfg.GetTeamsProgressResponse", [
            { no: 1, name: "teams", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TeamProgress }
        ]);
    }
    create(value?: PartialMessage<GetTeamsProgressResponse>): GetTeamsProgressResponse {
        const message = { teams: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetTeamsProgressResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTeamsProgressResponse): GetTeamsProgressResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated ctfg.TeamProgress teams */ 1:
                    message.teams.push(TeamProgress.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTeamsProgressResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated ctfg.TeamProgress teams = 1; */
        for (let i = 0; i < message.teams.length; i++)
            TeamProgress.internalBinaryWrite(message.teams[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ctfg.GetTeamsProgressResponse
 */
export const GetTeamsProgressResponse = new GetTeamsProgressResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Challenge$Type extends MessageType<Challenge> {
    constructor() {
        super("ctfg.Challenge", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "flag", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Challenge>): Challenge {
        const message = { name: "", flag: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Challenge>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Challenge): Challenge {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string flag */ 2:
                    message.flag = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Challenge, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string flag = 2; */
        if (message.flag !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.flag);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ctfg.Challenge
 */
export const Challenge = new Challenge$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAllChallengesRequest$Type extends MessageType<GetAllChallengesRequest> {
    constructor() {
        super("ctfg.GetAllChallengesRequest", []);
    }
    create(value?: PartialMessage<GetAllChallengesRequest>): GetAllChallengesRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetAllChallengesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAllChallengesRequest): GetAllChallengesRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetAllChallengesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ctfg.GetAllChallengesRequest
 */
export const GetAllChallengesRequest = new GetAllChallengesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAllChallengesResponse$Type extends MessageType<GetAllChallengesResponse> {
    constructor() {
        super("ctfg.GetAllChallengesResponse", [
            { no: 1, name: "challenges", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Challenge }
        ]);
    }
    create(value?: PartialMessage<GetAllChallengesResponse>): GetAllChallengesResponse {
        const message = { challenges: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetAllChallengesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAllChallengesResponse): GetAllChallengesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated ctfg.Challenge challenges */ 1:
                    message.challenges.push(Challenge.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAllChallengesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated ctfg.Challenge challenges = 1; */
        for (let i = 0; i < message.challenges.length; i++)
            Challenge.internalBinaryWrite(message.challenges[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ctfg.GetAllChallengesResponse
 */
export const GetAllChallengesResponse = new GetAllChallengesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetHomePageRequest$Type extends MessageType<SetHomePageRequest> {
    constructor() {
        super("ctfg.SetHomePageRequest", [
            { no: 1, name: "content", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SetHomePageRequest>): SetHomePageRequest {
        const message = { content: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetHomePageRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetHomePageRequest): SetHomePageRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string content */ 1:
                    message.content = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetHomePageRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string content = 1; */
        if (message.content !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.content);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ctfg.SetHomePageRequest
 */
export const SetHomePageRequest = new SetHomePageRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetHomePageRequest$Type extends MessageType<GetHomePageRequest> {
    constructor() {
        super("ctfg.GetHomePageRequest", []);
    }
    create(value?: PartialMessage<GetHomePageRequest>): GetHomePageRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetHomePageRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetHomePageRequest): GetHomePageRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetHomePageRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ctfg.GetHomePageRequest
 */
export const GetHomePageRequest = new GetHomePageRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetHomePageResponse$Type extends MessageType<GetHomePageResponse> {
    constructor() {
        super("ctfg.GetHomePageResponse", [
            { no: 1, name: "content", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetHomePageResponse>): GetHomePageResponse {
        const message = { content: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetHomePageResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetHomePageResponse): GetHomePageResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string content */ 1:
                    message.content = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetHomePageResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string content = 1; */
        if (message.content !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.content);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ctfg.GetHomePageResponse
 */
export const GetHomePageResponse = new GetHomePageResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ForgotPasswordRequest$Type extends MessageType<ForgotPasswordRequest> {
    constructor() {
        super("ctfg.ForgotPasswordRequest", [
            { no: 1, name: "email", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ForgotPasswordRequest>): ForgotPasswordRequest {
        const message = { email: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ForgotPasswordRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ForgotPasswordRequest): ForgotPasswordRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string email */ 1:
                    message.email = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ForgotPasswordRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string email = 1; */
        if (message.email !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.email);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ctfg.ForgotPasswordRequest
 */
export const ForgotPasswordRequest = new ForgotPasswordRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubmitWriteupRequest$Type extends MessageType<SubmitWriteupRequest> {
    constructor() {
        super("ctfg.SubmitWriteupRequest", [
            { no: 1, name: "content", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SubmitWriteupRequest>): SubmitWriteupRequest {
        const message = { content: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubmitWriteupRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubmitWriteupRequest): SubmitWriteupRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string content */ 1:
                    message.content = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubmitWriteupRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string content = 1; */
        if (message.content !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.content);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ctfg.SubmitWriteupRequest
 */
export const SubmitWriteupRequest = new SubmitWriteupRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetWriteupRequest$Type extends MessageType<GetWriteupRequest> {
    constructor() {
        super("ctfg.GetWriteupRequest", [
            { no: 1, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetWriteupRequest>): GetWriteupRequest {
        const message = { username: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetWriteupRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetWriteupRequest): GetWriteupRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string username */ 1:
                    message.username = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetWriteupRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string username = 1; */
        if (message.username !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.username);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ctfg.GetWriteupRequest
 */
export const GetWriteupRequest = new GetWriteupRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetWriteupResponse$Type extends MessageType<GetWriteupResponse> {
    constructor() {
        super("ctfg.GetWriteupResponse", [
            { no: 1, name: "content", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetWriteupResponse>): GetWriteupResponse {
        const message = { content: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetWriteupResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetWriteupResponse): GetWriteupResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string content */ 1:
                    message.content = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetWriteupResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string content = 1; */
        if (message.content !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.content);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ctfg.GetWriteupResponse
 */
export const GetWriteupResponse = new GetWriteupResponse$Type();
/**
 * @generated ServiceType for protobuf service ctfg.Backend
 */
export const Backend = new ServiceType("ctfg.Backend", [
    { name: "Register", options: {}, I: RegisterRequest, O: RegisterResponse },
    { name: "Login", options: {}, I: LoginRequest, O: LoginResponse },
    { name: "CurrentUser", options: {}, I: CurrentUserRequest, O: CurrentUserResponse },
    { name: "SubmitFlag", options: {}, I: SubmitFlagRequest, O: SubmitFlagResponse },
    { name: "SubmitEvidenceReport", options: {}, I: SubmitEvidenceReportRequest, O: SubmitEvidenceReportRequest },
    { name: "GetDiscoveredEvidence", options: {}, I: GetDiscoveredEvidenceRequest, O: GetDiscoveredEvidenceResponse },
    { name: "SubmitEvidence", options: {}, I: SubmitEvidenceRequest, O: SubmitEvidenceResponse },
    { name: "SubmitEvidenceConnection", options: {}, I: SubmitEvidenceConnectionRequest, O: SubmitEvidenceConnectionResponse },
    { name: "GetHomePage", options: {}, I: GetHomePageRequest, O: GetHomePageResponse },
    { name: "ForgotPassword", options: {}, I: ForgotPasswordRequest, O: Empty },
    { name: "SubmitWriteup", options: {}, I: SubmitWriteupRequest, O: Empty }
]);
/**
 * @generated ServiceType for protobuf service ctfg.Admin
 */
export const Admin = new ServiceType("ctfg.Admin", [
    { name: "UpsertChallenge", options: {}, I: UpsertChallengeRequest, O: Empty },
    { name: "DeleteChallenge", options: {}, I: DeleteChallengeRequest, O: Empty },
    { name: "GetTeamsProgress", options: {}, I: GetTeamsProgressRequest, O: GetTeamsProgressResponse },
    { name: "GetAllChallenges", options: {}, I: GetAllChallengesRequest, O: GetAllChallengesResponse },
    { name: "SetHomePage", options: {}, I: SetHomePageRequest, O: Empty },
    { name: "GetWriteup", options: {}, I: GetWriteupRequest, O: GetWriteupResponse }
]);
