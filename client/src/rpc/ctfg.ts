// @generated by protobuf-ts 2.2.3-alpha.1 with parameter client_none,generate_dependencies
// @generated from protobuf file "ctfg.proto" (package "ctfg", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message ctfg.SubmitEvidenceReportRequest
 */
export interface SubmitEvidenceReportRequest {
    /**
     * @generated from protobuf field: string url = 1;
     */
    url: string;
}
/**
 * @generated from protobuf message ctfg.SubmitEvidenceReportResponse
 */
export interface SubmitEvidenceReportResponse {
}
/**
 * @generated from protobuf message ctfg.LoginRequest
 */
export interface LoginRequest {
    /**
     * @generated from protobuf field: string email = 1;
     */
    email: string;
    /**
     * @generated from protobuf field: string password = 2;
     */
    password: string;
}
/**
 * @generated from protobuf message ctfg.LoginResponse
 */
export interface LoginResponse {
    /**
     * @generated from protobuf field: bool loggedIn = 1;
     */
    loggedIn: boolean;
}
/**
 * @generated from protobuf message ctfg.Evidence
 */
export interface Evidence {
    /**
     * @generated from protobuf field: uint32 id = 1;
     */
    id: number;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: int32 x = 3;
     */
    x: number;
    /**
     * @generated from protobuf field: int32 y = 4;
     */
    y: number;
}
/**
 * @generated from protobuf message ctfg.Connection
 */
export interface Connection {
    /**
     * @generated from protobuf field: uint32 id = 1;
     */
    id: number;
    /**
     * @generated from protobuf field: uint32 source = 2;
     */
    source: number;
    /**
     * @generated from protobuf field: uint32 destination = 3;
     */
    destination: number;
}
/**
 * @generated from protobuf message ctfg.GetDiscoveredEvidenceRequest
 */
export interface GetDiscoveredEvidenceRequest {
}
/**
 * @generated from protobuf message ctfg.GetDiscoveredEvidenceResponse
 */
export interface GetDiscoveredEvidenceResponse {
    /**
     * @generated from protobuf field: string report = 1;
     */
    report: string;
    /**
     * @generated from protobuf field: repeated ctfg.Evidence evidence = 2;
     */
    evidence: Evidence[];
    /**
     * @generated from protobuf field: repeated ctfg.Connection connections = 3;
     */
    connections: Connection[];
}
/**
 * @generated from protobuf message ctfg.SubmitEvidenceRequest
 */
export interface SubmitEvidenceRequest {
    /**
     * this could either be the name of some evidence or a flag.
     *
     * @generated from protobuf field: string evidence = 1;
     */
    evidence: string;
    /**
     * @generated from protobuf field: int32 x = 2;
     */
    x: number;
    /**
     * @generated from protobuf field: int32 y = 3;
     */
    y: number;
}
/**
 * @generated from protobuf message ctfg.SubmitEvidenceResponse
 */
export interface SubmitEvidenceResponse {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
}
/**
 * @generated from protobuf message ctfg.SubmitEvidenceConnectionRequest
 */
export interface SubmitEvidenceConnectionRequest {
    /**
     * @generated from protobuf field: uint32 source = 1;
     */
    source: number;
    /**
     * @generated from protobuf field: uint32 destination = 2;
     */
    destination: number;
}
/**
 * @generated from protobuf message ctfg.SubmitEvidenceConnectionResponse
 */
export interface SubmitEvidenceConnectionResponse {
    /**
     * @generated from protobuf field: bool created = 1;
     */
    created: boolean;
}
/**
 * @generated from protobuf message ctfg.RegisterRequest
 */
export interface RegisterRequest {
    /**
     * @generated from protobuf field: string username = 1;
     */
    username: string;
    /**
     * @generated from protobuf field: string email = 2;
     */
    email: string;
    /**
     * @generated from protobuf field: string password = 3;
     */
    password: string;
}
/**
 * @generated from protobuf message ctfg.RegisterResponse
 */
export interface RegisterResponse {
    /**
     * @generated from protobuf field: bool created = 1;
     */
    created: boolean;
}
/**
 * @generated from protobuf message ctfg.Page
 */
export interface Page {
    /**
     * @generated from protobuf field: string route = 1;
     */
    route: string;
    /**
     * @generated from protobuf field: string title = 2;
     */
    title: string;
    /**
     * @generated from protobuf field: string content = 3;
     */
    content: string;
}
/**
 * @generated from protobuf message ctfg.CurrentUserRequest
 */
export interface CurrentUserRequest {
}
/**
 * @generated from protobuf message ctfg.CurrentUserResponse
 */
export interface CurrentUserResponse {
    /**
     * @generated from protobuf field: string username = 1;
     */
    username: string;
    /**
     * @generated from protobuf field: repeated ctfg.Page pages = 2;
     */
    pages: Page[];
}
/**
 * @generated from protobuf message ctfg.GetChallengesRequest
 */
export interface GetChallengesRequest {
}
/**
 * @generated from protobuf message ctfg.Challenge
 */
export interface Challenge {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string description = 2;
     */
    description: string;
    /**
     * @generated from protobuf field: int32 value = 3;
     */
    value: number;
}
/**
 * @generated from protobuf message ctfg.GetChallengesResponse
 */
export interface GetChallengesResponse {
    /**
     * @generated from protobuf field: repeated ctfg.Challenge challenges = 1;
     */
    challenges: Challenge[];
}
/**
 * @generated from protobuf message ctfg.SubmitFlagRequest
 */
export interface SubmitFlagRequest {
    /**
     * @generated from protobuf field: string flag = 1;
     */
    flag: string;
}
/**
 * @generated from protobuf message ctfg.SubmitFlagResponse
 */
export interface SubmitFlagResponse {
    /**
     * @generated from protobuf field: bool correct = 1;
     */
    correct: boolean;
}
// @generated message type with reflection information, may provide speed optimized methods
class SubmitEvidenceReportRequest$Type extends MessageType<SubmitEvidenceReportRequest> {
    constructor() {
        super("ctfg.SubmitEvidenceReportRequest", [
            { no: 1, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SubmitEvidenceReportRequest>): SubmitEvidenceReportRequest {
        const message = { url: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubmitEvidenceReportRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubmitEvidenceReportRequest): SubmitEvidenceReportRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string url */ 1:
                    message.url = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubmitEvidenceReportRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string url = 1; */
        if (message.url !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.url);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ctfg.SubmitEvidenceReportRequest
 */
export const SubmitEvidenceReportRequest = new SubmitEvidenceReportRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubmitEvidenceReportResponse$Type extends MessageType<SubmitEvidenceReportResponse> {
    constructor() {
        super("ctfg.SubmitEvidenceReportResponse", []);
    }
    create(value?: PartialMessage<SubmitEvidenceReportResponse>): SubmitEvidenceReportResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubmitEvidenceReportResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubmitEvidenceReportResponse): SubmitEvidenceReportResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubmitEvidenceReportResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ctfg.SubmitEvidenceReportResponse
 */
export const SubmitEvidenceReportResponse = new SubmitEvidenceReportResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoginRequest$Type extends MessageType<LoginRequest> {
    constructor() {
        super("ctfg.LoginRequest", [
            { no: 1, name: "email", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "password", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LoginRequest>): LoginRequest {
        const message = { email: "", password: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LoginRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoginRequest): LoginRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string email */ 1:
                    message.email = reader.string();
                    break;
                case /* string password */ 2:
                    message.password = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoginRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string email = 1; */
        if (message.email !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.email);
        /* string password = 2; */
        if (message.password !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.password);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ctfg.LoginRequest
 */
export const LoginRequest = new LoginRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoginResponse$Type extends MessageType<LoginResponse> {
    constructor() {
        super("ctfg.LoginResponse", [
            { no: 1, name: "loggedIn", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<LoginResponse>): LoginResponse {
        const message = { loggedIn: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LoginResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoginResponse): LoginResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool loggedIn */ 1:
                    message.loggedIn = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoginResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool loggedIn = 1; */
        if (message.loggedIn !== false)
            writer.tag(1, WireType.Varint).bool(message.loggedIn);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ctfg.LoginResponse
 */
export const LoginResponse = new LoginResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Evidence$Type extends MessageType<Evidence> {
    constructor() {
        super("ctfg.Evidence", [
            { no: 1, name: "id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "x", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "y", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Evidence>): Evidence {
        const message = { id: 0, name: "", x: 0, y: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Evidence>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Evidence): Evidence {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 id */ 1:
                    message.id = reader.uint32();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* int32 x */ 3:
                    message.x = reader.int32();
                    break;
                case /* int32 y */ 4:
                    message.y = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Evidence, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).uint32(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* int32 x = 3; */
        if (message.x !== 0)
            writer.tag(3, WireType.Varint).int32(message.x);
        /* int32 y = 4; */
        if (message.y !== 0)
            writer.tag(4, WireType.Varint).int32(message.y);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ctfg.Evidence
 */
export const Evidence = new Evidence$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Connection$Type extends MessageType<Connection> {
    constructor() {
        super("ctfg.Connection", [
            { no: 1, name: "id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "source", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "destination", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Connection>): Connection {
        const message = { id: 0, source: 0, destination: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Connection>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Connection): Connection {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 id */ 1:
                    message.id = reader.uint32();
                    break;
                case /* uint32 source */ 2:
                    message.source = reader.uint32();
                    break;
                case /* uint32 destination */ 3:
                    message.destination = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Connection, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).uint32(message.id);
        /* uint32 source = 2; */
        if (message.source !== 0)
            writer.tag(2, WireType.Varint).uint32(message.source);
        /* uint32 destination = 3; */
        if (message.destination !== 0)
            writer.tag(3, WireType.Varint).uint32(message.destination);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ctfg.Connection
 */
export const Connection = new Connection$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDiscoveredEvidenceRequest$Type extends MessageType<GetDiscoveredEvidenceRequest> {
    constructor() {
        super("ctfg.GetDiscoveredEvidenceRequest", []);
    }
    create(value?: PartialMessage<GetDiscoveredEvidenceRequest>): GetDiscoveredEvidenceRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetDiscoveredEvidenceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDiscoveredEvidenceRequest): GetDiscoveredEvidenceRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetDiscoveredEvidenceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ctfg.GetDiscoveredEvidenceRequest
 */
export const GetDiscoveredEvidenceRequest = new GetDiscoveredEvidenceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDiscoveredEvidenceResponse$Type extends MessageType<GetDiscoveredEvidenceResponse> {
    constructor() {
        super("ctfg.GetDiscoveredEvidenceResponse", [
            { no: 1, name: "report", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "evidence", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Evidence },
            { no: 3, name: "connections", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Connection }
        ]);
    }
    create(value?: PartialMessage<GetDiscoveredEvidenceResponse>): GetDiscoveredEvidenceResponse {
        const message = { report: "", evidence: [], connections: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetDiscoveredEvidenceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDiscoveredEvidenceResponse): GetDiscoveredEvidenceResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string report */ 1:
                    message.report = reader.string();
                    break;
                case /* repeated ctfg.Evidence evidence */ 2:
                    message.evidence.push(Evidence.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated ctfg.Connection connections */ 3:
                    message.connections.push(Connection.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDiscoveredEvidenceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string report = 1; */
        if (message.report !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.report);
        /* repeated ctfg.Evidence evidence = 2; */
        for (let i = 0; i < message.evidence.length; i++)
            Evidence.internalBinaryWrite(message.evidence[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated ctfg.Connection connections = 3; */
        for (let i = 0; i < message.connections.length; i++)
            Connection.internalBinaryWrite(message.connections[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ctfg.GetDiscoveredEvidenceResponse
 */
export const GetDiscoveredEvidenceResponse = new GetDiscoveredEvidenceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubmitEvidenceRequest$Type extends MessageType<SubmitEvidenceRequest> {
    constructor() {
        super("ctfg.SubmitEvidenceRequest", [
            { no: 1, name: "evidence", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "x", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "y", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SubmitEvidenceRequest>): SubmitEvidenceRequest {
        const message = { evidence: "", x: 0, y: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubmitEvidenceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubmitEvidenceRequest): SubmitEvidenceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string evidence */ 1:
                    message.evidence = reader.string();
                    break;
                case /* int32 x */ 2:
                    message.x = reader.int32();
                    break;
                case /* int32 y */ 3:
                    message.y = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubmitEvidenceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string evidence = 1; */
        if (message.evidence !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.evidence);
        /* int32 x = 2; */
        if (message.x !== 0)
            writer.tag(2, WireType.Varint).int32(message.x);
        /* int32 y = 3; */
        if (message.y !== 0)
            writer.tag(3, WireType.Varint).int32(message.y);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ctfg.SubmitEvidenceRequest
 */
export const SubmitEvidenceRequest = new SubmitEvidenceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubmitEvidenceResponse$Type extends MessageType<SubmitEvidenceResponse> {
    constructor() {
        super("ctfg.SubmitEvidenceResponse", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SubmitEvidenceResponse>): SubmitEvidenceResponse {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubmitEvidenceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubmitEvidenceResponse): SubmitEvidenceResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubmitEvidenceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ctfg.SubmitEvidenceResponse
 */
export const SubmitEvidenceResponse = new SubmitEvidenceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubmitEvidenceConnectionRequest$Type extends MessageType<SubmitEvidenceConnectionRequest> {
    constructor() {
        super("ctfg.SubmitEvidenceConnectionRequest", [
            { no: 1, name: "source", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "destination", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SubmitEvidenceConnectionRequest>): SubmitEvidenceConnectionRequest {
        const message = { source: 0, destination: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubmitEvidenceConnectionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubmitEvidenceConnectionRequest): SubmitEvidenceConnectionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 source */ 1:
                    message.source = reader.uint32();
                    break;
                case /* uint32 destination */ 2:
                    message.destination = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubmitEvidenceConnectionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 source = 1; */
        if (message.source !== 0)
            writer.tag(1, WireType.Varint).uint32(message.source);
        /* uint32 destination = 2; */
        if (message.destination !== 0)
            writer.tag(2, WireType.Varint).uint32(message.destination);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ctfg.SubmitEvidenceConnectionRequest
 */
export const SubmitEvidenceConnectionRequest = new SubmitEvidenceConnectionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubmitEvidenceConnectionResponse$Type extends MessageType<SubmitEvidenceConnectionResponse> {
    constructor() {
        super("ctfg.SubmitEvidenceConnectionResponse", [
            { no: 1, name: "created", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SubmitEvidenceConnectionResponse>): SubmitEvidenceConnectionResponse {
        const message = { created: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubmitEvidenceConnectionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubmitEvidenceConnectionResponse): SubmitEvidenceConnectionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool created */ 1:
                    message.created = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubmitEvidenceConnectionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool created = 1; */
        if (message.created !== false)
            writer.tag(1, WireType.Varint).bool(message.created);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ctfg.SubmitEvidenceConnectionResponse
 */
export const SubmitEvidenceConnectionResponse = new SubmitEvidenceConnectionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterRequest$Type extends MessageType<RegisterRequest> {
    constructor() {
        super("ctfg.RegisterRequest", [
            { no: 1, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "email", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "password", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RegisterRequest>): RegisterRequest {
        const message = { username: "", email: "", password: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RegisterRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegisterRequest): RegisterRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string username */ 1:
                    message.username = reader.string();
                    break;
                case /* string email */ 2:
                    message.email = reader.string();
                    break;
                case /* string password */ 3:
                    message.password = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RegisterRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string username = 1; */
        if (message.username !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.username);
        /* string email = 2; */
        if (message.email !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.email);
        /* string password = 3; */
        if (message.password !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.password);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ctfg.RegisterRequest
 */
export const RegisterRequest = new RegisterRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterResponse$Type extends MessageType<RegisterResponse> {
    constructor() {
        super("ctfg.RegisterResponse", [
            { no: 1, name: "created", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<RegisterResponse>): RegisterResponse {
        const message = { created: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RegisterResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegisterResponse): RegisterResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool created */ 1:
                    message.created = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RegisterResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool created = 1; */
        if (message.created !== false)
            writer.tag(1, WireType.Varint).bool(message.created);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ctfg.RegisterResponse
 */
export const RegisterResponse = new RegisterResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Page$Type extends MessageType<Page> {
    constructor() {
        super("ctfg.Page", [
            { no: 1, name: "route", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "content", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Page>): Page {
        const message = { route: "", title: "", content: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Page>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Page): Page {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string route */ 1:
                    message.route = reader.string();
                    break;
                case /* string title */ 2:
                    message.title = reader.string();
                    break;
                case /* string content */ 3:
                    message.content = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Page, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string route = 1; */
        if (message.route !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.route);
        /* string title = 2; */
        if (message.title !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.title);
        /* string content = 3; */
        if (message.content !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.content);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ctfg.Page
 */
export const Page = new Page$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CurrentUserRequest$Type extends MessageType<CurrentUserRequest> {
    constructor() {
        super("ctfg.CurrentUserRequest", []);
    }
    create(value?: PartialMessage<CurrentUserRequest>): CurrentUserRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CurrentUserRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CurrentUserRequest): CurrentUserRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: CurrentUserRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ctfg.CurrentUserRequest
 */
export const CurrentUserRequest = new CurrentUserRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CurrentUserResponse$Type extends MessageType<CurrentUserResponse> {
    constructor() {
        super("ctfg.CurrentUserResponse", [
            { no: 1, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "pages", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Page }
        ]);
    }
    create(value?: PartialMessage<CurrentUserResponse>): CurrentUserResponse {
        const message = { username: "", pages: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CurrentUserResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CurrentUserResponse): CurrentUserResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string username */ 1:
                    message.username = reader.string();
                    break;
                case /* repeated ctfg.Page pages */ 2:
                    message.pages.push(Page.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CurrentUserResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string username = 1; */
        if (message.username !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.username);
        /* repeated ctfg.Page pages = 2; */
        for (let i = 0; i < message.pages.length; i++)
            Page.internalBinaryWrite(message.pages[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ctfg.CurrentUserResponse
 */
export const CurrentUserResponse = new CurrentUserResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetChallengesRequest$Type extends MessageType<GetChallengesRequest> {
    constructor() {
        super("ctfg.GetChallengesRequest", []);
    }
    create(value?: PartialMessage<GetChallengesRequest>): GetChallengesRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetChallengesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetChallengesRequest): GetChallengesRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetChallengesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ctfg.GetChallengesRequest
 */
export const GetChallengesRequest = new GetChallengesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Challenge$Type extends MessageType<Challenge> {
    constructor() {
        super("ctfg.Challenge", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "value", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Challenge>): Challenge {
        const message = { name: "", description: "", value: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Challenge>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Challenge): Challenge {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* int32 value */ 3:
                    message.value = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Challenge, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* int32 value = 3; */
        if (message.value !== 0)
            writer.tag(3, WireType.Varint).int32(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ctfg.Challenge
 */
export const Challenge = new Challenge$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetChallengesResponse$Type extends MessageType<GetChallengesResponse> {
    constructor() {
        super("ctfg.GetChallengesResponse", [
            { no: 1, name: "challenges", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Challenge }
        ]);
    }
    create(value?: PartialMessage<GetChallengesResponse>): GetChallengesResponse {
        const message = { challenges: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetChallengesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetChallengesResponse): GetChallengesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated ctfg.Challenge challenges */ 1:
                    message.challenges.push(Challenge.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetChallengesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated ctfg.Challenge challenges = 1; */
        for (let i = 0; i < message.challenges.length; i++)
            Challenge.internalBinaryWrite(message.challenges[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ctfg.GetChallengesResponse
 */
export const GetChallengesResponse = new GetChallengesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubmitFlagRequest$Type extends MessageType<SubmitFlagRequest> {
    constructor() {
        super("ctfg.SubmitFlagRequest", [
            { no: 1, name: "flag", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SubmitFlagRequest>): SubmitFlagRequest {
        const message = { flag: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubmitFlagRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubmitFlagRequest): SubmitFlagRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string flag */ 1:
                    message.flag = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubmitFlagRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string flag = 1; */
        if (message.flag !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.flag);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ctfg.SubmitFlagRequest
 */
export const SubmitFlagRequest = new SubmitFlagRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubmitFlagResponse$Type extends MessageType<SubmitFlagResponse> {
    constructor() {
        super("ctfg.SubmitFlagResponse", [
            { no: 1, name: "correct", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SubmitFlagResponse>): SubmitFlagResponse {
        const message = { correct: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubmitFlagResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubmitFlagResponse): SubmitFlagResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool correct */ 1:
                    message.correct = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubmitFlagResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool correct = 1; */
        if (message.correct !== false)
            writer.tag(1, WireType.Varint).bool(message.correct);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ctfg.SubmitFlagResponse
 */
export const SubmitFlagResponse = new SubmitFlagResponse$Type();
/**
 * @generated ServiceType for protobuf service ctfg.Backend
 */
export const Backend = new ServiceType("ctfg.Backend", [
    { name: "Register", options: {}, I: RegisterRequest, O: RegisterResponse },
    { name: "Login", options: {}, I: LoginRequest, O: LoginResponse },
    { name: "CurrentUser", options: {}, I: CurrentUserRequest, O: CurrentUserResponse },
    { name: "GetChallenges", options: {}, I: GetChallengesRequest, O: GetChallengesResponse },
    { name: "SubmitFlag", options: {}, I: SubmitFlagRequest, O: SubmitFlagResponse },
    { name: "SubmitEvidenceReport", options: {}, I: SubmitEvidenceReportRequest, O: SubmitEvidenceReportRequest },
    { name: "GetDiscoveredEvidence", options: {}, I: GetDiscoveredEvidenceRequest, O: GetDiscoveredEvidenceResponse },
    { name: "SubmitEvidence", options: {}, I: SubmitEvidenceRequest, O: SubmitEvidenceResponse },
    { name: "SubmitEvidenceConnection", options: {}, I: SubmitEvidenceConnectionRequest, O: SubmitEvidenceConnectionResponse }
]);
